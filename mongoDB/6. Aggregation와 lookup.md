## 1.  Aggregation Framework (집계 프레임워크)

   * 입력: 컬렉션의 문서들이 들어옴
   * 처리: 조립 라인의 여러 단계를 거치면서 데이터가 필터링되고, 그룹화되고, 계산되고, 형태가 바뀜
   * 출력: 최종적으로 새로운 형태의 문서가 나옴

### 주요 Stages
각 단계를 stage라고 부름
- `$match`: 필터링 단계. 특정 조건을 만족하는 문서만 다음 단계로 넘김. (SQL의 WHERE 절과 유사)
* `$group`: 그룹화 단계. 특정 필드를 기준으로 문서들을 그룹으로 묶고, 각 그룹에 대해 합계(sum), 평균(avg), 개수(count) 등을 계산합니다. (SQL의 GROUP BY와 유사)
* `$sort`: 정렬 단계. 특정 필드를 기준으로 문서를 오름차순(1) 또는 내림차순(-1)으로 정렬. (SQL의 ORDER BY와 유사)
* `$project`: 형태 변형 단계. 출력할 문서의 구조를 새롭게 만듭니다. 특정 필드만 선택하거나, 필드 이름을 바꾸거나, 새로운 필드를 추가할 수 있음 (SQL의 SELECT 절과 유사하지만 훨씬 강력함)
* `$unwind`: 배열 분해 단계. 문서 내의 배열 필드를 각 요소별로 별개의 문서로 풀어줌.
* `$lookup`: 외부 조인 단계. 다른 컬렉션의 데이터를 가져와 현재 문서에 붙이는 역할.


### $lookup
```json
    {
      $lookup: {
        from: "<조인할 다른 컬렉션 이름>",
        localField: "<현재 컬렉션의 조인 기준 필드>",
        foreignField: "<다른 컬렉션의 조인 기준 필드>",
        as: "<결과가 저장될 새로운 필드 이름>"
      }
    }
```
- localField와 foreignField의 값이 일치하는 문서를 찾dma
- 찾아온 문서들이 배열(Array) 형태로 저장될 새로운 필드의 이름. 조인된 결과가 하나이더라도 **항상 배열로 들어옴**

#### 예시
 orders 목록을 조회하되, 각 주문에 해당하는 products의 상세 정보를 포함
 
products 컬렉션
```json
    { "_id": 1, "name": "노트북", "price": 1500000 }
    { "_id": 2, "name": "마우스", "price": 50000 }
```

orders 컬렉션
```json
     { "_id": 101, "productId": 1, "quantity": 1 }
     { "_id": 102, "productId": 2, "quantity": 3 }
```

 Aggregation Pipeline 실행 
 1. lookup
 ```json
 db.orders.aggregate([
	 // --- 스테이지 1: $lookup ---
    // orders 컬렉션에 products 컬렉션을 조인한다.
	 {
		 $lookup: {
			from: "products",
			localField: "productId",
			foreignField: "_id",
			as: "prodcutInfo"
		 }
	 }
 ])
 
    //중간 결과
     {
       "_id": 101,
       "productId": 1,
       "quantity": 1,
       "productInfo": [ // <-- 배열(Array) 형태
         { "_id": 1, "name": "노트북", "price": 1500000 }
       ]
     },
     {
      "_id": 102,
      "productId": 2,
      "quantity": 3,
      "productInfo": [ // <-- 배열(Array) 형태
        { "_id": 2, "name": "마우스", "price": 50000 }
      ]
    }
 ```
 2.  $unwind: 배열을 풀어주기
 -  $unwind의 값으로는 풀어줄 필드 이름을 문자열로 지정
```json
  {
      $unwind: "$productInfo" // productInfo 배열을 풀어준다.
  }
  
  
  //unwind결과
     {
       "_id": 101,
       "productId": 1,
       "quantity": 1,
       "productInfo": { //  이제 객체(Object)
         "_id": 1,
         "name": "노트북",
         "price": 1500000
       }
    },
    {
      "_id": 102,
      "productId": 2,
      "quantity": 3,
      "productInfo": { //  이제 객체(Object)
        "_id": 2,
        "name": "마우스",
        "price": 50000
      }
    }
```
3. $project: 최종 보고서 양식 만들기
   * 주문 ID (orderId)
   * 주문 수량 (quantity)
   * 제품 이름 (productName)
   * 총 주문 금액 (totalPrice)
```json
    // 이전 $unwind 스테이지에 이어서...
     {
       $project: {
         _id: 0, // 기본 _id 필드는 제외
         orderId: "$_id", // 원래 _id 필드를 orderId 라는 이름으로 변경
         quantity: 1, // quantity 필드는 그대로 포함 (1은 포함을 의미)
         productName: "$productInfo.name", // productInfo 객체 안의 name 필드를 productName으로 지정
         totalPrice: { $multiply: ["$quantity", "$productInfo.price"] } // 수량 * 단가를 계산하여 totalPrice 필드 생성
       }
 }
 //최종 결과
     {
       "orderId": 101,
       "quantity": 1,
       "productName": "노트북",
       "totalPrice": 1500000
     },
     {
       "orderId": 102,
       "quantity": 3,
       "productName": "마우스",
      "totalPrice": 150000
    }
```

```json
db.orders.aggreagte([
	{
		$lookup: {
			from: "products",
			localField: "productId",
			foreignField: "_id",
			as: "productInfo"
		}
	},
	{
		$unwind: "$productInfo"
	},
	{
		$project: {
			_id: 0,
			orderId: "$_id",
			quantity: 1,
			productName: "$productInfo.name",
			totalPrice: {$multiply: ["$quantity", "$productInfo.price"]}
		}
	}
])
```