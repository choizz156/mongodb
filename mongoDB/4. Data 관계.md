## 1. 포함(Embedding / Denormalization)
- 관련된 데이터를 부모 도큐먼트 안에 배열이나 하위 도큐먼트 형태로 포함시키는 방식
- 비정규화 모델이라고도 함
```json
 {
       "_id": "post123",
       "title": "MongoDB 데이터 모델링",
       "author": "Gemini",
       "content": "...",
       "comments": [
         { "author": "user1", "text": "좋은 정보 감사합니다!", "timestamp": ISODate(...) },
        { "author": "user2", "text": "이해가 잘 되네요.", "timestamp": ISODate(...)          }      
     ]
 }
```

#### 장점
- 빠른 읽기 성능
- 도큐먼트에 대한 업데이트는 원자적으로 처리됨
#### 단점
- 데이터 중복 가능성
- 포함된 데이터가 계속 늘어다나 보면 도큐먼트 크기 제한에 도달할 수 있음

#### when?
- one to few 관계에 적합
- 데이터가 항상 부모 도큐먼트와 함께 조회될 경우
- 데이터의 양이 제한 적이고 무한정 늘어나지 않는 경우

## 2. 참조 (Referencing / Normalization)
- 한 도큐먼트가 다른 도큐먼트의 `_id` 값을 저장하여 관계를 맺는 방식
- 정규화 모델이라고도 함
```json
{ "_id": "product_A", "name": "노트북", "price": 1500000 }
{ "_id": "product_B", "name": "마우스", "price": 50000 }

   {
      "_id": "order_xyz",
      "customer_id": "user777",
      "order_date": ISODate(...),
      "product_ids": [ "product_A", "product_B" ] // 상품의 _id를 배열로 참조
   }
```

#### 장점
- 데이터 중복 없음: 상품 정보가 변경되어도 해당 도큐먼트만 수정하면 되므로 데이터 정합성을 유지하기 쉬움
- 유연성: 복잡한 "One-to-Many"나 "Many-to-Many" 관계를 표현하기에 적합
- 크기 제한 없음: 관계가 아무리 많아져도 도큐먼트 크기 제한에 거의 영향을 받지 않음
#### 단점
- 추가 쿼리 필요
	- 관련된 데이터를 가져오려면 여러 번의 쿼리가 필요합니다. (예: 주문 내역을 보고 상품의 상세 정보를 가져오려면 orders 조회 후, product_ids를 가지고 products를 다시 조회해야 함)
- `$lookup` 연산자
	- MongoDB는 JOIN과 유사한 `$lookup`이라는 집계(aggregation) 연산자를 제공하지만, RDBMS의 JOIN만큼 항상 효율적이거나 간단하지는  않음
#### when
- n:m 관계에 적합
- 참조되는 데이터가 독립적으로 자주 조회되거나 수정될 때 유용
- 포함 모델을 사용했을 때 16MB 크기 제한을 초과할 가능성이 있을 때 사용

>[!Note]
> - 성능을 위해서는 포함 모델을, 유연성을 위해서는 참조 모델을 사용
